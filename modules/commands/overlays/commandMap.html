<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
		<title>Command Map</title>
		<link rel="stylesheet" href="style.css">
		<script src="http://www.thebarkingotter.com/gameworks/lib/HtmlUtility.js"></script>
        <script src="http://www.thebarkingotter.com/gameworks/lib/TwitchAPI.js"></script>
        <script src="https://polyfill.io/v3/polyfill.min.js?features=default"></script>
        <script>

            const VIEW_BASIC_TEXT = "basic";                    // plain text
            const VIEW_CLUMPY = "clumpy";                       // randomly placed text divs with flags
            const VIEW_PRIDE = "pride";                         // google map with markers and flags in info windows
            const VIEW_PRIDE_WITH_FLAGS = "prideWithFlags";     //TODO: google map with pfp and flags as markers

            const CLIENT_ID = "rat7tckwdp2962ahwqlorv2qg4lzcr";
            const TOKEN = "t9ljlzh0wh2zm8xd2bwag3d4ilqsp6";

            let UNSPECIFIED_LOCATION_RANGE = 
            {
                left: -176,
                right: -92,
                top: 15,
                bottom: -59
            };

            let flagDataPath = "res/flagData.json";
            let recordPath = "commandRecord_thebarkingotter.txt";

            let width = 1280;
            let height = 720;
            let view = "basic";

            let pfpSize = 32;
            let flagSize = 16;

            let flagData = null;
            let previouslyUsedLocations = new Set();

            let map = null;
            window.initMap = initMap;

            async function Init()
            {
                thisUrl = document.location.toString();
				imageContainer = document.getElementById("imageContainer");
				ParseUrl();

				width = GetOrFallback("w", 1280);
				height = GetOrFallback("h", 720);
                view = GetOrFallback("view", "basic");
                pfpSize = GetOrFallback("pfpSize", pfpSize);
                flagSize = GetOrFallback("flagSize", flagSize);

                flagData = await FetchPage(flagDataPath);

                InitTwitchApi(CLIENT_ID, TOKEN);

                let stateMap = await FetchPage(recordPath);
                LoadCommandHistory(stateMap);
            }
            
            function initMap()
            {
                map = new google.maps.Map(document.getElementById("map"), {
                    center: { lat: 0, lng: 0 },
                    zoom: 2,
                });
            }

            function OnError()
            {
                console.log("an error occurred");
            }

            async function LoadCommandHistory(stateMap)
            {
                let simplifiedMap = {};

                for(let user in stateMap)
                {
                    simplifiedMap[user] = {};
                    let userMap = simplifiedMap[user];

                    for(let command in stateMap[user])
                    {
                        let firstWord = command.substring(0, command.indexOf(' '));
                        if(userMap.hasOwnProperty(firstWord))
                            ++userMap[firstWord];
                        else
                            userMap[firstWord] = 1;
                    }

                    switch(view)
                    {
                        case VIEW_BASIC_TEXT:       RenderAsParagraph(user, userMap);               break;
                        case VIEW_CLUMPY:           RenderAsTextGroups(user, userMap);              break;
                        case VIEW_PRIDE:            await RenderPrideView(user, stateMap[user]);    break;
                        case VIEW_PRIDE_WITH_FLAGS:                                                 break;
                    }
                }
            }

            function RenderAsParagraph(user, userMap)
            {
                let container = document.getElementById("Content");

                let newDiv = document.createElement("div");
                container.appendChild(newDiv);
                let html = user + " has used<p>"
                for(let command in userMap)
                {
                    html += command + " " + userMap[command] + " times<p>";
                }
                newDiv.innerHTML = html;
            }

            function RenderAsTextGroups(user, userMap)
            {
                const MIN_RADIUS = 10;
                const MAX_RADIUS = 20;

                let container = document.getElementById("Content");

                let userDiv = document.createElement("div");
                container.appendChild(userDiv);

                let nameWidth = user.length * 5;
                let nameDiv = PlaceName(user, {
                    x: MAX_RADIUS,
                    y: MAX_RADIUS,
                    w: width - nameWidth - 2 * MAX_RADIUS,
                    h: height - 2 * MAX_RADIUS
                });
                userDiv.appendChild(nameDiv.div);

                for(let command in userMap)
                {
                    let count = parseInt(userMap[command]);
                    let position = GetOffsetAboveOrBelow(MIN_RADIUS, MAX_RADIUS, 45);
                    position.x += nameDiv.x;
                    position.y += nameDiv.y;

                    let commandDiv = document.createElement("div");
                    nameDiv.appendChild(commandDiv);
                    commandDiv.style.position = "absolute";
                    commandDiv.style.left = position.x.toString() + "px";
                    commandDiv.style.top = position.y.toString() + "px";
                    commandDiv.style.fontWeight = "normal";
                    commandDiv.innerText = command;
                }
            }

            async function RenderPrideView(user, userMap)
            {
                const MIN_RADIUS = 10;
                const MAX_RADIUS = 20;
                const HEIGHT = 20;

                let flagList = new Set();
                let hasFlag = false;
                let locationCandidates = new Set();
                //let nameDiv = null;
                
                for(let command in userMap)
                {
                    let words = command.split(' ');
                    let locationCandidate = null;
                    let locationProcessing = true;
                    if(words[0] == '!pride' || words[0] == '!flyyourflags')
                    {
                        /*let container = document.getElementById("Content");

                        let userDiv = document.createElement("div");
                        //userDiv.style.textAlign = "center";
                        container.appendChild(userDiv);

                        if(nameDiv == null)
                        {
                            let nameWidth = user.length * 5;
                            nameDiv = PlaceName(user, {
                                x: MAX_RADIUS,
                                y: MAX_RADIUS,
                                w: width - nameWidth - 2 * MAX_RADIUS,
                                h: height - 2 * MAX_RADIUS
                            });
                            nameDiv.div.appendChild(document.createElement("br"));
                            userDiv.appendChild(nameDiv.div);
                        }*/
                        
                        //TODO:
                        /*

                        - handle multi word locations
                            -
                        - handle multiple uses of the command (merge them properly)

                        */

                        // merge different aliases for the same flag together
                        for(let i = 1; i < words.length; ++i)
                        {
                            let arg = words[i].toLowerCase();
                            if(flagData.FLAG_MAP.hasOwnProperty(arg))
                            {
                                arg = flagData.FLAG_MAP[arg];
                            }

                            let index = flagData.FLAG_LIST.indexOf(arg);
                            if(index != -1)
                            {
                                flagList.add(arg);
                                hasFlag = true;
                                if(locationCandidate != null)
                                    locationProcessing = false;
                            }
                            else
                            {
                                if(locationCandidate == null)
                                {
                                    locationCandidate = arg + " ";
                                }
                                else if(locationProcessing)
                                {
                                    locationCandidate += arg + " ";
                                }
                            }
                        }
                    }

                    if(locationCandidate != null)
                        locationCandidates.add(locationCandidate);
                }

                if(!hasFlag)
                {
                    flagList.add("progressive");
                }

                // find a location that gets results
                let latLong = null;
                let requestCount = 0;
                for(let location of locationCandidates)
                {
                    let request = {
                        query: location,
                        fields: ['name', 'geometry'],
                    };

                    let service = new google.maps.places.PlacesService(map);
                    ++requestCount;
                    service.findPlaceFromQuery(request, function(results, status)
                    {
                        if (status === google.maps.places.PlacesServiceStatus.OK)
                        {
                            let lat = results[0].geometry.location.lat();
                            let lng = results[0].geometry.location.lng();

                            if(previouslyUsedLocations.has(results[0].name))
                            {
                                lat += -2 + Math.random() * 4;
                                lng += -2 + Math.random() * 4;
                            }

                            latLong = new google.maps.LatLng(lat, lng);
                            requestCount = 0;

                            previouslyUsedLocations.add(results[0].name);
                        }
                        else
                            --requestCount;
                    });
                }

                while(requestCount > 0)
                {
                    await Pause(100);
                }

                // if none of the locations worked
                if(latLong == null)
                {
                    // find a random x,y in range using UNSPECIFIED_RANGE
                    let long = UNSPECIFIED_LOCATION_RANGE.left + Math.random() * (UNSPECIFIED_LOCATION_RANGE.right - UNSPECIFIED_LOCATION_RANGE.left);
                    let lat = UNSPECIFIED_LOCATION_RANGE.bottom + Math.random() * (UNSPECIFIED_LOCATION_RANGE.top - UNSPECIFIED_LOCATION_RANGE.bottom);
                    latLong = new google.maps.LatLng(lat, long);
                }

                // Flags in infoWindow
                //const infoWindow = CreateInfoWindow(flagList);

                let profilePic = await GetProfilePicUrl(user);

                createMarker(latLong, pfpSize, profilePic);



                // Flags as markers
                const OFFSET = 2;
                let lat = latLong.lat();
                let lng = latLong.lng();
                latLong = new google.maps.LatLng(lat, lng);
                for(let flag of flagList)
                {
                    let fileName = "res/flag_" + flag + ".gif";
                    createMarker(latLong, flagSize, fileName);

                    lng += OFFSET;
                    latLong = new google.maps.LatLng(lat, lng);
                }
            }

            function CreateInfoWindow(flagList)
            {
                let flagDiv = document.createElement("div");

                for(let flag in flagList)
                {
                    let fileName = "res/flag_" + flag + ".gif";
                    let img = document.createElement("img");
                    img.src = fileName;
                    img.onload = function()
                    {
                        img.height = HEIGHT;
                    };
                    flagDiv.appendChild(img);
                }

                return new google.maps.InfoWindow({
                        content: flagDiv,
                    });
            }

            function createMarker(place, size, img = null, infoWindow = null)
            {
                if (place == null)
                    return;

                let markerConfig = {
                    map: map,
                    position: place
                };

                if(img != null)
                    markerConfig.icon = {
                        url: img,
                        scaledSize: new google.maps.Size(size, size),
                        // The origin for this image is (0, 0).
                        origin: new google.maps.Point(0, 0),
                        // The anchor for this image is the base of the flagpole at (0, 32).
                        anchor: new google.maps.Point(0, 0),
                    };

                const marker = new google.maps.Marker(markerConfig);  
                
                if(infoWindow != null)
                {
                    marker.addListener("click", () =>
                    {
                        infoWindow.open({
                            anchor: marker,
                            map,
                            shouldFocus: false,
                        });
                    }   );
                }
            }

            function PlaceName(name, rect)
            {
                let nameDiv = document.createElement("div");
                let namePosition = GetRandomPointInRect(rect.x,
                    rect.y, rect.w, rect.h);
                nameDiv.style.position = "absolute";
                nameDiv.style.left = namePosition.x.toString() + "px";
                nameDiv.style.top = namePosition.y.toString() + "px";
                nameDiv.style.fontWeight = "bold";
                nameDiv.innerText = name;
                return { div:nameDiv, x:namePosition.x, y:namePosition.y };
            }

            function GetOffsetAboveOrBelow(minRadius, maxRadius, arcOffset)
            {
                let position = null;
                let upDown = Math.floor(Math.random() * 2);
                if(upDown == 0)
                    return GetRandomPointInArc(minRadius, maxRadius, 0, 1);//90 - arcOffset, 90 + arcOffset);
                else
                    return GetRandomPointInArc(minRadius, maxRadius, 90, 91);//270 - arcOffset, 270 + arcOffset);
            }

        </script>
        </head>
    <body onload="Init()">
        <div id="map"></div>
        <script
            src="https://maps.googleapis.com/maps/api/js?key=AIzaSyD7rNKYQltIE5Gm1QCl9_Ebl_MJ70Dg0LY&callback=initMap&libraries=places&v=weekly"
            defer
        ></script>

        <div style="position:absolute; left:0px; top:0px">
            Pride flag animations created by SuperQ https://twitter.com/suuperQ
        </div>

        <div id="Content">
        </div>
    </body>
</html>